#############################################################################
##
##  DerivedCategories: Derived categories for abelian categories
##
##  Copyright 2020, Kamal Saleh, University of Siegen
##
#############################################################################

# This works even ovrt P^n x P^m, but slower for P^n
# 

if IsPackageMarkedForLoading( "NConvex", ">= 2019.12.01" ) then
  
  ##
  InstallMethodWithCache( MonomialsOfDegree,
          [ IsHomalgGradedRing, IsHomalgModuleElement ],
  function( S, deg )
    local p, indeterminates, n, degree, weights, matrix, equations, polyhedron, solutions;
    
    if not IsBound( S!.ComputedMonomials ) then
      
      S!.ComputedMonomials := [ ];
      
    fi;
    
    p := PositionProperty( S!.ComputedMonomials, m -> m[ 1 ] = deg );
    
    if p <> fail then
      
      return S!.ComputedMonomials[ p ][ 2 ];
      
    fi;
    
    Error( "?" );
    indeterminates := Indeterminates( S );
    
    n := Size( indeterminates );
    
    degree := UnderlyingMorphism( deg );
    
    degree := MatrixOfMap( degree );
    
    degree := EntriesOfHomalgMatrixAttr( degree );
    
    degree := List( degree, HomalgElementToInteger );
    
    weights := WeightsOfIndeterminates( S );
    
    matrix := List( weights, UnderlyingMorphism );
    
    matrix := List( matrix, d -> MatrixOfMap( d ) );
    
    matrix := TransposedMatrix( UnionOfRows( matrix ) );
    
    matrix := EntriesOfHomalgMatrixAsListListAttr( matrix );
    
    equations := ListN( degree, matrix, { e, d } -> Concatenation( [ -e ], d ) );
    
    equations := Concatenation( equations, -equations );
    
    equations := Concatenation( equations, IdentityMat( n + 1 ){ [ 2 .. n + 1 ] } );
    
    polyhedron := PolyhedronByInequalities( equations );
    
    solutions := LatticePointsGenerators( polyhedron )[ 1 ];
    
    solutions := List( solutions, sol -> Product( ListN( indeterminates, sol, \^ )  ) );
    
    if HasIsExteriorRing( S ) and IsExteriorRing( S ) then
      
      solutions := Filtered( solutions, sol -> not IsZero( sol ) );
      
    fi;
    
    Add( S!.ComputedMonomials, [ deg, solutions ] );
    
    return solutions;
    
  end );
  
  
  BASIS_OF_EXTERNAL_HOM_FROM_S_TO_DIRECT_SUM_OF_TWISTS_OF_S :=
    function( M )
    local S, twists, df_twists, positions, L, mats, current_mat, i;
    
    S := UnderlyingHomalgRing( M );
    
    twists := -GeneratorDegrees( M );
    
    if IsEmpty( twists ) then
      
      return [ ];
      
    fi;
    
    df_twists := DuplicateFreeList( twists );
    
    df_twists := List( df_twists, d -> MonomialsOfDegree( S, d ) );
    
    positions := List( DuplicateFreeList( twists ), d -> Positions( twists, d ) );
    
    L := [ ];
    
    List( [ 1 .. Length( df_twists ) ],
      i -> List( positions[ i ],
            function( p )
              L[ p ] := df_twists[ i ];
              return 0;
            end )
      );
    
    mats := [  ];
    
    for i in [ 1 .. Length( L ) ] do
      
      if not IsEmpty( L[ i ] ) then
        
        current_mat := ListWithIdenticalEntries( Length( twists ), [ Zero( S ) ] );
        
        current_mat[ i ] := L[ i ];
        
        mats := Concatenation( mats, Cartesian( current_mat ) );
        
      fi;
      
    od;
    
    return mats;
    
  end;
 
else
  
  Print( "You are running DerivedCategories without NConvex.\n" );
  Print( "Hence, some operations for coherent sheaves may not apply.\n" );
  
fi;

if IsPackageMarkedForLoading( "BBGG", ">= 2019.12.06" ) then
  
  ##
  InstallMethod( FullSubcategoryGeneratedByDirectSumsOfTwistsOfStructureSheaf,
            [ IsHomalgGradedRing and IsFreePolynomialRing ],
    function( S )
      local graded_pres, k, coh, generalized_morphism_cat, sh, name, full, is_additive;
      
      graded_pres := GradedLeftPresentations( S );
      
      DisableSanityChecks( graded_pres );
      DeactivateCachingOfCategory( graded_pres );
      CapCategorySwitchLogicOff( graded_pres );
      
      k := UnderlyingNonGradedRing( CoefficientsRing( S ) );
      
      coh := CoherentSheavesOverProjectiveSpace( S );
      
      DisableSanityChecks( coh );
      DeactivateCachingOfCategory( coh );
      CapCategorySwitchLogicOff( coh );
     
      generalized_morphism_cat := UnderlyingGeneralizedMorphismCategory( coh );
      
      DisableSanityChecks( generalized_morphism_cat );
      DeactivateCachingOfCategory( generalized_morphism_cat );
      CapCategorySwitchLogicOff( generalized_morphism_cat );
      
      sh := CanonicalProjection( coh );
      
      name := "Full subcategory generated by direct sums of twists of the structure sheaf in ";
      
      full := FullSubcategory( coh, name : FinalizeCategory := false, is_additive := true );
      
      ##
      AddPreCompose( full,
        function( alpha, beta )
        
          alpha := UnderlyingCell( alpha );
          
          beta := UnderlyingCell( beta );
          
          alpha := HonestRepresentative( UnderlyingGeneralizedMorphism( alpha ) );
          
          beta := HonestRepresentative( UnderlyingGeneralizedMorphism( beta ) );
          
          return ApplyFunctor( sh, PreCompose( alpha, beta ) ) / full;
          
      end, 99 );
      
      ##
      AddAdditionForMorphisms( full,
        function( alpha, beta )
        
          alpha := UnderlyingCell( alpha );
          
          beta := UnderlyingCell( beta );
          
          alpha := HonestRepresentative( UnderlyingGeneralizedMorphism( alpha ) );
          
          beta := HonestRepresentative( UnderlyingGeneralizedMorphism( beta ) );
          
          return ApplyFunctor( sh, AdditionForMorphisms( alpha, beta ) ) / full;
          
      end, 99 );
     
      AddIsWellDefinedForObjects( full,
        function( o )
          
          o := UnderlyingCell( o );
          
          o := UnderlyingHonestObject( o );
          
          return IsZero( NrRows( UnderlyingMatrix( o ) ) );
          
      end );
      
      AddIsWellDefinedForMorphisms( full,
        function( alpha )
          return IsWellDefined( Source( alpha ) ) and IsWellDefined( Range( alpha ) )
                  and IsWellDefined( UnderlyingCell( alpha ) );
                  
      end );
      
      SetIsLinearCategoryOverCommutativeRing( full, true );
      
      SetCommutativeRingOfLinearCategory( full, k );
      
      AddMultiplyWithElementOfCommutativeRingForMorphisms( full,
        function( r, alpha )
          
          alpha := UnderlyingCell( alpha );
          
          alpha := HonestRepresentative( UnderlyingGeneralizedMorphism( alpha ) );
          
          alpha := GradedPresentationMorphism( Source( alpha ), ( r / S ) * UnderlyingMatrix( alpha ), Range( alpha ) );
          
          return ApplyFunctor( sh, alpha ) / full;
          
      end );
      
      AddBasisOfExternalHom( full,
        function( M, N )
          local twists_M, rank_M, twists_N, rank_N, twists, hom_M_N, mats, B;
          
          M := UnderlyingHonestObject( UnderlyingCell( M ) );
          
          N := UnderlyingHonestObject( UnderlyingCell( N ) );
          
          twists_M := -GeneratorDegrees( M );
          
          rank_M := Size( twists_M );
          
          twists_N := -GeneratorDegrees( N );
          
          rank_N := Size( twists_N );
          
          twists := Concatenation( List( twists_M, a -> List( twists_N, b -> -a + b ) ) );
          
          hom_M_N := GradedFreeLeftPresentation( Size( twists ), S, -twists );
          
          mats := BASIS_OF_EXTERNAL_HOM_FROM_S_TO_DIRECT_SUM_OF_TWISTS_OF_S( hom_M_N );
          
          B := List( mats, mat -> GradedPresentationMorphism( M, HomalgMatrix( mat, rank_M, rank_N, S ), N ) );
          
          return List( B, b -> ApplyFunctor( sh, b ) / full );
          
      end );
      
      AddCoefficientsOfMorphismWithGivenBasisOfExternalHom( full,
        function( phi, B )
          local list_of_entries, N, sol, current_position, position_of_non_zero_entry, current_entry,
            current_coeff_mat, current_coeff, current_mono, position_in_basis, j;
          
          if B = [  ] then
            
            return [  ];
            
          fi;
          
          phi := UnderlyingCell( phi );
          
          phi := HonestRepresentative( UnderlyingGeneralizedMorphism( phi ) );
          
          list_of_entries := EntriesOfHomalgMatrixAttr( UnderlyingMatrix( phi ) );
          
          N := Size( list_of_entries );
          
          B := List( B, UnderlyingCell );
          
          B := List( B, b -> HonestRepresentative( UnderlyingGeneralizedMorphism( b ) ) );
          
          B := List( B, b -> EntriesOfHomalgMatrixAttr( UnderlyingMatrix( b ) ) );
          
          sol := ListWithIdenticalEntries( Size( B ), Zero( k ) );
          
          current_position := 0;
          
          while current_position < N do
            
            position_of_non_zero_entry := PositionProperty( [ current_position + 1.. N ], p -> not IsZero( list_of_entries[ p ] ) );
            
            if position_of_non_zero_entry = fail then
              
              break;
              
            fi;
            
            position_of_non_zero_entry := position_of_non_zero_entry + current_position;
             
            current_entry := list_of_entries[ position_of_non_zero_entry ];
            current_coeff_mat := Coefficients( EvalRingElement( current_entry ) );
            
            for j in [ 1 .. NrRows( current_coeff_mat ) ] do
              
              current_coeff := current_coeff_mat[ j, 1 ];
              current_mono := current_coeff_mat!.monomials[ j ]/S;
              position_in_basis := PositionProperty( B, b -> b[ position_of_non_zero_entry ] = current_mono );
              sol[ position_in_basis ] := current_coeff/k;
              
            od;
            
            current_position := position_of_non_zero_entry;
            
          od;
          
          return sol;
          
      end );
      
      Finalize( full );
      
      DisableSanityChecks( full );
      #DeactivateCachingOfCategory( full );
      CapCategorySwitchLogicOff( full );
     
      return full;
      
  end );

  ##
  InstallMethod( FullSubcategoryGeneratedByTwistsOfStructureSheaf,
            [ IsHomalgGradedRing and IsFreePolynomialRing ],
    function( S )
      local cat, name, full;
      
      cat := FullSubcategoryGeneratedByDirectSumsOfTwistsOfStructureSheaf( S );
      
      name := "Full subcategory generated by twists of the structure sheaf in ";
      
      full := FullSubcategory( cat, name : FinalizeCategory := false );
      
      AddIsWellDefinedForObjects( full,
        function( o )
          
          o := UnderlyingCell( UnderlyingCell( o ) );
          
          o := UnderlyingMatrix( UnderlyingHonestObject( o ) );
          
          return NrRows( o ) = 0 and NrCols( o ) = 1;
          
      end );
      
      AddIsWellDefinedForMorphisms( full,
        function( alpha )
          
          return IsWellDefined( Source( alpha ) ) and IsWellDefined( Range( alpha ) )
                  and IsWellDefined( UnderlyingCell( alpha ) );
                  
      end );
      
      Finalize( full );
      
      return full;
     
  end );
  
fi;

