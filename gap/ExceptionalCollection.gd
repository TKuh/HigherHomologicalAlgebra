#############################################################################
##
##  DerivedCategories: Derived categories for abelian categories
##
##  Copyright 2020, Kamal Saleh, University of Siegen
##
#! @Chapter Exceptional collections
#!
#############################################################################



####################################
##
#! @Section Constructors
##
####################################

#! @Description
#!  The GAP category of exceptional collections.
#! @Arguments object
#! @Returns true or false
DeclareCategory( "IsExceptionalCollection", IsObject );

#! @Description
#!  If the input is full subcategory <A>A</A> in some category <C>C</C>, generated by finite number of objects 
#!  <A>A!.Objects</A>, then the output is the strong exceptional collection defined by these objects.
#!  If the input is a list of objects <A>L</A> of objects in some category <C>C</C>, 
#!  then the output is <A>CreateExceptionalCollection( A )</A>, where <A>A := FullSubcategoryGeneratedByListOfObjects(C,L)</A>.
#! @Arguments arg
#! @Returns IsExceptionalCollection
DeclareGlobalFunction( "CreateExceptionalCollection" );

#! @Description
#!  If the input is full subcategory <A>A</A> in some category <C>C</C>, generated by finite number of objects 
#!  <A>A!.Objects</A>, then the output is the strong exceptional collection defined by these objects returned as
#!  an attribute for <A>A</A>.
#! @Arguments A
#! @Returns IsExceptionalCollection
DeclareAttribute( "ExceptionalCollection", IsCapFullSubcategory );

#! @Description
#!  Returns the full subcategory that is generated by the elements of the strong exceptional collection <A>E</A>.
#! @Arguments E
#! @Returns 
DeclareAttribute( "DefiningFullSubcategory", IsExceptionalCollection );

#! @Description
#!  Returns the endomorphism quiver algebra of the exceptional collection <A>E</A>.
#! @Arguments E
#! @Returns a quiver algebra
DeclareAttribute( "EndomorphismAlgebraOfExceptionalCollection", IsExceptionalCollection );

#! @Description
#!  Returns the direct sum of the objects of the exceptional collection <A>E</A>.
#! @Arguments E
#! @Returns an object
DeclareAttribute( "TiltingObject", IsExceptionalCollection );

#! @Description
#!  Returns the number of objects of the exceptional collection <A>E</A>.
#! @Arguments E
#! @Returns IsInt
DeclareAttribute( "NumberOfObjects", IsExceptionalCollection );

#! @Description
#!  Returns a list of the objects of the exceptional collection <A>E</A>.
#! @Arguments E
#! @Returns IsList
DeclareAttribute( "UnderlyingObjects", IsExceptionalCollection );

#! @Description
#!  Returns the full subcategory generated by <C>TiltingObject</C>(<A>E</A>).
#! @Arguments E
#! @Returns a category
DeclareAttribute( "TiltingObjectAsCategory", IsExceptionalCollection );

#! @Description
#!  Returns the embedding functor of <C>DefiningFullSubcategory</C>(<A>E</A>) in <C>TiltingObjectAsCategory</C>(<A>E</A>).
#! @Arguments E
#! @Returns a functor
DeclareOperation( "InterpretMorphismInExceptionalCollectionAsEndomorphismOfTiltingObject",
    [ IsExceptionalCollection, IsCapCategoryMorphismInAFullSubcategory ] );

#! @Description
#!  Returns the $i$'th object in <A>E</A>.
#! @Arguments E, i
#! @Returns an object
DeclareOperation( "\[\]", [ IsExceptionalCollection, IsInt ] );

#! @Description
#!  It returns a basis for the vector space of morphisms from $E_i$ to $E_j$ that can not be factored
#!  through any other object in the exceptional collection.
#! @Arguments E, i, j
#! @Returns IsList
DeclareOperation( "Arrows", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns a generating set for the vector space of morphisms from $E_i$ to $E_j$ that can be factored
#!  along at least one object in the exceptional collection.
#! @Arguments E, i, j
#! @Returns IsList
DeclareOperation( "OtherPaths", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns the union of <C>Arrows</C> and <C>OtherPaths</C> applied
#!  on the same input. In other words it returns a generating set for the vector space Hom$(E_i,E_j)$.
#! @Arguments E, i, j
#! @Returns IsList
DeclareOperation( "Paths", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns a basis for <C>Paths( E, i, j )</C>.
#! @Arguments E, i, j
#! @Returns IsList
DeclareOperation( "BasisForPaths", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns labels for <C>Arrows( E, i, j )</C>.
#! @Arguments E, i, j
#! @Returns IsList
DeclareOperation( "LabelsForArrows", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns labels for <C>OtherPaths( E, i, j )</C>.
#! @Arguments E, i, j
#! @Returns a list of lists
DeclareOperation( "LabelsForOtherPaths", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns labels for <C>Paths( E, i, j )</C>.
#! @Arguments E, i, j
#! @Returns a list of lists
DeclareOperation( "LabelsForPaths", [ IsExceptionalCollection, IsInt, IsInt ] );

#! @Description
#!  It returns labels for <C>Paths( E, i, j )</C>.
#! @Arguments E, i, j
#! @Returns a list of lists
DeclareOperation( "LabelsForBasisForPaths", [ IsExceptionalCollection, IsInt, IsInt ] );

####################################
##
#! @Section General Operations
##
####################################

#! @Description
#!  The arguments are two objects <A>A</A>, <A>B</A> and a list of morphisms <A>L</A>$:=(f_i:A\to B)$ for $i=1,\dots,n$ that live in
#!  a category equipped with homomorphism structure $(1,H(-,-),\nu)$. The output is
#!  the morphism $\langle \nu(f_1),\nu(f_2),\dots,\nu(f_n)\rangle:\oplus_{i=1}^n 1 \to H(A,B)$.
#! @Arguments A, B, L
#! @Returns a morphism in range category of homomorphism structure
DeclareOperation( "InterpretListOfMorphismsAsOneMorphismInRangeCategoryOfHomomorphismStructure",
    [ IsCapCategoryObject, IsCapCategoryObject, IsList ] );

#! @Description
#!  The arguments are a field <A>F</A> and three non-negative integers <A>m</A>, <A>n</A> and <A>r</A>
#!  It returns a quiver algebra with <A>m</A> vertices, <A>n</A> arrows and at most <A>r</A> relations; and whose indecomposable 
#!  projective or injective objects define an exceptional collection.
#! @Arguments F, m, n, r
#! @Returns a quiver path algebra
DeclareGlobalFunction( "RandomQuiverAlgebraWhoseIndecProjectiveRepsAreExceptionalCollection" );

DeclareOperation( "QuiverAlgebraFromExceptionalCollection",
    [ IsExceptionalCollection, IsField ] );


#! @Description
#!  The argument is a list of morphism <A>L</A> in some $k$-linear category equipped with homomorphism structure.
#!  The output is the relations between the morphisms.
#! @Arguments L
#! @Returns a list of ring elements
DeclareGlobalFunction( "RelationsBetweenMorphisms" );

##
#! @Description
#!  The argument is an abelian category <A>C</A> with enouph projectives. The output the full subcategory
#!  generated by projective objects in <A>C</A>.
#! @Arguments cat
#! @Returns a full subcategory
DeclareAttribute( "FullSubcategoryGeneratedByProjectiveObjects", IsCapCategory );

##
#! @Description
#!  The argument is an abelian category <A>C</A> with enouph injectives. The output the full subcategory
#!  generated by injective objects in <A>C</A>.
#! @Arguments cat
#! @Returns a full subcategory
DeclareAttribute( "FullSubcategoryGeneratedByInjectiveObjects", IsCapCategory );

#! @Description
#!  The argument is a category of quiver representations over some finite dimensional quiver algebra or
#!  a category of functors into a matrix category of some homalg field.
#!  The output the full subcategory generated by the indecomposable projective objects.
#! @Arguments cat
#! @Returns a full subcategory
DeclareAttribute( "FullSubcategoryGeneratedByIndecProjectiveObjects",
        IsCapCategory );

#! @Description
#!  The argument is a category of quiver representations over some finite dimensional quiver algebra or
#!  a category of functors into a matrix category of some homalg field.
#!  The output the full subcategory generated by the indecomposable injectives objects.
#! @Arguments cat
#! @Returns a full subcategory
DeclareAttribute( "FullSubcategoryGeneratedByIndecInjectiveObjects",
        IsCapCategory );

#! @Description
#!  The argument is an algebroid <A>algebroid</A> over some algebra $A$. The output is
#! <C>FullSubcategoryGeneratedByIndecProjectiveObjects</C>($A^{op}$).
#! @Arguments algebroid
#! @Returns a full subcategory
DeclareAttribute( "FullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra",
        IsAlgebroid );


