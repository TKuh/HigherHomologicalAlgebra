#############################################################################
##
## DerivedCategories: Derived categories for abelian categories
##
## Copyright 2020, Kamal Saleh, University of Siegen
##
##  Functors
##
#############################################################################

##
InstallMethod( EquivalenceFromFullSubcategoryGeneratedByProjectiveObjectsIntoAdditiveClosureOfIndecProjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local A, projs, indec_projs, add_indec_projs, r, name, F;
    
    A := AlgebraOfCategory( cat );
    
    projs := FullSubcategoryGeneratedByProjectiveObjects( cat );
    
    indec_projs := FullSubcategoryGeneratedByIndecProjectiveObjects( cat );
    
    add_indec_projs := AdditiveClosure( indec_projs  );
    
    DeactivateCachingOfCategory( add_indec_projs );
    
    name := "Equivalence functor from additive full subcategory generated by projective objects in additive closure";
    
    F := CapFunctor( name, projs, add_indec_projs );
    
    AddObjectFunction( F,
      function( a )
        local d;
        
        d := DecomposeProjectiveQuiverRepresentation( UnderlyingCell( a ) );
        
        if Size( d ) = 1 and IsZero( d[ 1 ] ) then
          
          d := ZeroObject( add_indec_projs );
          
          SetIsZeroForObjects( d, true );
          
          return d;
          
        fi;
        
        d := List( d, m -> AsSubcategoryCell( indec_projs, Source( m ) ) );
        
        return AdditiveClosureObject( d, add_indec_projs ); 
      
    end );
    
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        local d_source_cell, d_range_cell, alpha_cell, iso, mat;
         
        if ( HasIsZeroForObjects( s ) and IsZeroForObjects( s ) ) or ( HasIsZeroForObjects( r ) and IsZeroForObjects( r ) ) then
          
          return ZeroMorphism( s, r );
          
        fi;
        
        d_source_cell := DecomposeProjectiveQuiverRepresentation( UnderlyingCell( Source( alpha ) ) );
        
        d_range_cell := DecomposeProjectiveQuiverRepresentation( UnderlyingCell( Range( alpha ) ) );
        
        alpha_cell := UnderlyingCell( alpha );
        
        iso := IsomorphismFromProjectiveRepresentationIntoCanonicalDecomposition( UnderlyingCell( Range( alpha ) ) );
        
        d_range_cell := List( d_range_cell, Source );
        
        d_range_cell := List( [ 1 .. Size( d_range_cell ) ],
          i -> PreCompose(
                  iso,
                  ProjectionInFactorOfDirectSumWithGivenDirectSum( d_range_cell, i, Range( iso ) )
                ) );
                
        mat := List( d_source_cell, u -> List( d_range_cell, v -> PreCompose( [ u, alpha_cell, v ] ) ) );
        
        mat := List( mat, row -> List( row, m -> AsSubcategoryCell( indec_projs, m ) ) );
        
        return AdditiveClosureMorphism( s, mat, r );
        
    end );
    
    return F;
    
end );

##
InstallMethod( EquivalenceFromAdditiveClosureOfIndecProjectiveObjectsIntoFullSubcategoryGeneratedByProjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local indec_projs, projs, I;
    
    indec_projs := FullSubcategoryGeneratedByIndecProjectiveObjects( cat );
    
    projs := FullSubcategoryGeneratedByProjectiveObjects( cat );
    
    I := InclusionFunctor( indec_projs );
    
    I := RestrictFunctorToFullSubcategoryOfRange( I, projs );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I!.Name := "Equivalence functor additive closure into additive full subcategory generated by projective objects";
    
    return I;
    
end );

##
InstallMethod( EquivalenceFromFullSubcategoryGeneratedByInjectiveObjectsIntoAdditiveClosureOfIndecInjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local A, injs, indec_injs, add_indec_injs, r, name, F;
    
    A := AlgebraOfCategory( cat );
    
    injs := FullSubcategoryGeneratedByInjectiveObjects( cat );
    
    indec_injs := FullSubcategoryGeneratedByIndecInjectiveObjects( cat );
    
    add_indec_injs := AdditiveClosure( indec_injs  );
    
    DeactivateCachingOfCategory( add_indec_injs );
    
    r := RandomBoldTextColor( );
    
    name := "Equivalence functor from additive full subcategory generated by injective objects in additive closure";
    
    F := CapFunctor( name, injs, add_indec_injs );
    
    AddObjectFunction( F,
      function( a )
        local d;
        
        d := DecomposeInjectiveQuiverRepresentation( UnderlyingCell( a ) );
        
        if Size( d ) = 1 and IsZero( d[ 1 ] ) then
          
          return ZeroObject( add_indec_injs );
          
        fi;
        
        d := List( d, m -> AsSubcategoryCell( indec_injs, Range( m ) ) );
        
        return AdditiveClosureObject( d, add_indec_injs ); 
        
    end );
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        local d_source_cell, d_range_cell, alpha_cell, iso, mat;
        
        if ( HasIsZeroForObjects( s ) and IsZeroForObjects( s ) ) or ( HasIsZeroForObjects( r ) and IsZeroForObjects( r ) ) then
          
          return ZeroMorphism( s, r );
          
        fi;
        
        d_source_cell := DecomposeInjectiveQuiverRepresentation( UnderlyingCell( Source( alpha ) ) );
        
        d_range_cell := DecomposeInjectiveQuiverRepresentation( UnderlyingCell( Range( alpha ) ) );
        
        alpha_cell := UnderlyingCell( alpha );
        
        iso := IsomorphismOntoInjectiveRepresentationFromCanonicalDecomposition( UnderlyingCell( Source( alpha ) ) );
        
        d_source_cell := List( d_source_cell, Range );
        
        d_source_cell := List( [ 1 .. Size( d_source_cell ) ],
          i -> PostCompose(
                  iso,
                  InjectionOfCofactorOfDirectSumWithGivenDirectSum( d_source_cell, i, Source( iso ) )
                ) );
                
        mat := List( d_source_cell, u -> List( d_range_cell, v -> PreCompose( [ u, alpha_cell, v ] ) ) );
        
        mat := List( mat, row -> List( row, m -> AsSubcategoryCell( indec_injs, m ) ) );
        
        return AdditiveClosureMorphism( s, mat, r );
        
    end );
    
    return F;
  
end );

##
InstallMethod( EquivalenceFromAdditiveClosureOfIndecInjectiveObjectsIntoFullSubcategoryGeneratedByInjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local indec_injs, injs, I;
    
    indec_injs := FullSubcategoryGeneratedByIndecInjectiveObjects( cat );
    
    injs := FullSubcategoryGeneratedByInjectiveObjects( cat );
    
    I := InclusionFunctor( indec_injs );
    
    I := RestrictFunctorToFullSubcategoryOfRange( I, injs );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I!.Name := "Equivalence functor additive closure into additive full subcategory generated by injective objects";
    
    return I;
    
end );

##
InstallMethod( IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsAlgebroid ],
  function( algebroid )
    local A, A_op, full, ambient_cat, quiver_op, nr_vertices, basis, projs, projs_in_subcategory, r, name, F;
    
    A := UnderlyingQuiverAlgebra( algebroid );
    
    A_op := OppositeAlgebra( A );
    
    full := FullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    ambient_cat := AmbientCategory( full );
    
    quiver_op := QuiverOfAlgebra( A_op );
    
    nr_vertices := NumberOfVertices( quiver_op );
    
    basis := BasisOfProjectives( A_op );
    
    projs := IndecProjRepresentations( A_op );
    
    r := RandomBoldTextColor( );
    
    name := "Isomorphism functor from algebroid into full subcategory generated by indecomposable projective objects";
    
    F := CapFunctor( name, algebroid, full );
    
    AddObjectFunction( F,
      function( a )
        local i, aa, p;
        
        i := VertexIndex( UnderlyingVertex( a ) );
        
        aa := basis[ PositionProperty( basis, b -> [ A_op.( String( Vertex( quiver_op, i ) ) ) ] in b ) ];
        
        p := projs[ PositionProperty( projs, p -> DimensionVector( p ) = List( aa, Size ) ) ];
        
        return AsSubcategoryCell( full, p );
        
      end );
      
    AddMorphismFunction( F,
      function( s, alpha, r )
        local e, mor;
        
        e := UnderlyingQuiverAlgebraElement( alpha );
        
        e := OppositeAlgebraElement( e );
        
        mor := MorphismBetweenIndecProjectivesGivenByElement( 
                UnderlyingCell( s ),
                e,
                UnderlyingCell( r ) );
                
        return AsSubcategoryCell( full, mor );
        
      end );
      
    return F;
    
end );

##
InstallMethod( IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsExceptionalCollection ],
  function( collection )
    local full, iso_1, algebroid, iso_2, iso, ind_projs, r, name, cell_func;
    
    full := DefiningFullSubcategory( collection );
    
    iso_1 := IsomorphismOntoAlgebroid( collection );
    
    algebroid := AsCapCategory( Range( iso_1 ) );
    
    iso_2 := IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    iso := PreCompose( iso_1, iso_2 );
    
    ind_projs := AsCapCategory( Range( iso ) );
    
    name := "Isomorphism functor from exceptional collection in full subcategory generated by indecomposable projective objects";
    
    cell_func := c -> ApplyFunctor( iso, c );
    
    return FunctorFromLinearCategoryByTwoFunctions( name, full, ind_projs, cell_func, cell_func );
end );

##
InstallMethod( IsomorphismFromFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsExceptionalCollection ],
  function( collection )
    local full, iso_1, algebroid, iso_2, iso, ind_projs, r, name, cell_func;
    
    full := DefiningFullSubcategory( collection );
    
    iso_1 := IsomorphismFromAlgebroid( collection );
    
    algebroid := AsCapCategory( Source( iso_1 ) );
    
    iso_2 := IsomorphismFromFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    iso := PostCompose( iso_1, iso_2 );
    
    ind_projs := AsCapCategory( Source( iso ) );
    
    name := "Isomorphism functor from full subcategory generated by indecomposable projective objects into exceptional collection";
    
    cell_func := c -> ApplyFunctor( iso, c );
    
    return FunctorFromLinearCategoryByTwoFunctions( name, ind_projs, full, cell_func, cell_func );
    
end );

##
InstallMethod( IsomorphismFromFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsAlgebroid ],
  function( algebroid )
    local A, A_op, full, quiver_op, nr_vertices, basis, projs, r, name, object_func, morphism_func;
    
    A := UnderlyingQuiverAlgebra( algebroid );
    
    A_op := OppositeAlgebra( A );
    
    full := FullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    quiver_op := QuiverOfAlgebra( A_op );
    
    nr_vertices := NumberOfVertices( quiver_op );
    
    basis := BasisOfProjectives( A_op );
    
    projs := IndecProjRepresentations( A_op );
    
    name := "Isomorphism functor from full subcategory generated by indecomposable projective objects into algebroid";
    
    object_func :=
      function( a )
        local p, i;
        
        p := UnderlyingCell( a );
        
        p := basis[ PositionProperty( basis, b -> DimensionVector( p ) = List( b, Size ) ) ];
        
        i := PositionProperty( [ 1 .. nr_vertices ], i -> [ A_op.( String( Vertex( quiver_op, i ) ) ) ] in p );
        
        return ObjectInAlgebroid( algebroid, Vertex( QuiverOfAlgebra( A ), i ) );
        
      end;
      
    morphism_func :=
      function( alpha )
        local s, r, basis, I, images, dim, rel;
        
        s := object_func( Source( alpha ) );
        
        r := object_func( Range( alpha ) );
        
        basis := BasisOfExternalHom( s, r );
        
        I := IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
        
        images := List( basis, b -> ApplyFunctor( I, b ) );
        
        dim := Size( basis );
        
        rel := RelationsBetweenMorphisms( Concatenation( [ alpha ], images ) );
        
        if Size( rel ) > 1 then
        
          Error( "This should not happen!\n" );
          
        fi;
        
        rel := AdditiveInverse( Inverse( rel[ 1 ][ 1 ] ) ) * rel[ 1 ];
        
        rel := rel{ [ 2 .. dim + 1 ] };
        
        if IsEmpty( rel ) then
          
          return ZeroMorphism( s, r );
          
        else
          
          return rel * basis;
          
        fi;
        
      end;
      
    return FunctorFromLinearCategoryByTwoFunctions( name, full, algebroid, object_func, morphism_func );
    
end );

##
InstallMethod( IsomorphismOntoAlgebroid,
        [ IsExceptionalCollection ],
  function( collection )
    local n, full, A, algebroid, r, name, object_func, morphism_func;
    
    n := NumberOfObjects( collection );
    
    full := DefiningFullSubcategory( collection );
    
    A := EndomorphismAlgebra( collection );
    
    algebroid := Algebroid( A );
    
    name := "Isomorphism functor from exceptional collection into algebroid";
    
    object_func :=
      function( e )
        local p;
        
        p := PositionProperty( [ 1 .. n ], i -> IsEqualForObjects( e, collection[ i ] ) );
        
        return SetOfObjects( algebroid )[ p ];
        
    end;
    
    morphism_func :=
      function( phi )
        local s, source, i, r, range, j, basis, labels, dim, paths, rel, v;
        
        s := Source( phi );
        
        source := object_func( s );
        
        i := PositionProperty( [ 1 .. n ], k -> IsEqualForObjects( s, collection[ k ] ) );
        
        r := Range( phi );
        
        range := object_func( r );
        
        j := PositionProperty( [ 1 .. n ], k -> IsEqualForObjects( r, collection[ k ] ) );
        
        basis := BasisForPaths( collection, i, j );
        
        v := collection!.char;
        
        if IsEmpty( basis ) then
          
          return ZeroMorphism( source, range );
          
        fi;
        
        labels := LabelsForBasisForPaths( collection, i, j );
        
        dim := Length( basis );
        
        if i > j then
          
          return ZeroMorphism( source, range );
          
        elif i = j then
          
          paths := [ IdentityMorphism( algebroid.( i ) ) ]; # Because the quiver has no loops.
          
        else
          
          paths := List( labels, label ->
                  PreCompose(
                  List( label, arrow_label ->
                    algebroid.( Concatenation( 
                                  v,
                                  String( arrow_label[ 1 ] ),
                                  "_",
                                  String( arrow_label[ 2 ] ),
                                  "_",
                                  String( arrow_label[ 3 ] ) )
                              ) ) ) );
        fi;
        
        rel := RelationsBetweenMorphisms( Concatenation( [ phi ], basis ) );
        
        if Length( rel ) > 1 then
          
          Error( "This should not happen, please report this" );
          
        fi;
        
        rel := AdditiveInverse( Inverse( rel[ 1 ][ 1 ] ) ) * rel[ 1 ];
        
        return rel{ [ 2 .. dim + 1 ] } * paths;
        
    end;
    
    return FunctorFromLinearCategoryByTwoFunctions( name, full, algebroid, object_func, morphism_func );
    
end );

##
InstallMethod( IsomorphismFromAlgebroid,
        [ IsExceptionalCollection ],
  function( collection )
    local n, full, A, algebroid, r, name, object_func, morphism_func;
    
    n := NumberOfObjects( collection );
    
    full := DefiningFullSubcategory( collection );
    
    A := EndomorphismAlgebra( collection );
    
    algebroid := Algebroid( A );
    
    name := "Isomorphism functor from algebroid into exceptional collection";
    
    object_func :=
      function( e )
        local p;
        
        p := VertexIndex( UnderlyingVertex( e ) );
        
        return collection[ p ];
        
    end;
    
    morphism_func :=
      function( phi )
        local source, range, s, i, r, j, e, paths, coeffs, arrow_list, paths_list;
        
        source := object_func( Source( phi ) );
        
        range := object_func( Range( phi ) );
        
        s := Source( phi );
        
        i := VertexIndex( UnderlyingVertex( s ) );
        
        r := Range( phi );
        
        j := VertexIndex( UnderlyingVertex( r ) );
        
        e := Representative( UnderlyingQuiverAlgebraElement( phi ) );
        
        if IsZero( e ) then
          
          return ZeroMorphism( source, range );
          
        fi;
        
        paths := Paths( e );
        
        coeffs := Coefficients( e );
        
        if Size( paths ) = 1 and Source( paths[ 1 ] ) = Target( paths[ 1 ] ) then
          
          return coeffs * [ IdentityMorphism( source ) ];
          
        fi;
        
        arrow_list := List( paths, ArrowList );
        
        arrow_list := List( arrow_list, 
          l -> List( l, arrow -> [
                                    VertexIndex( Source( arrow ) ),
                                    VertexIndex( Target( arrow ) ),
                                    Int( SplitString( Label( arrow ), "_" )[ 3 ] )
                                 ]
                    ) );
                    
        paths_list := List( arrow_list,
          l -> PreCompose(
                   List( l, indices -> Arrows( collection, indices[ 1 ], indices[ 2 ] )[ indices[ 3 ] ] )
                    ) );  
                    
        return coeffs * paths_list;
        
    end;
    
    return FunctorFromLinearCategoryByTwoFunctions( name, algebroid, full, object_func, morphism_func );
    
end );

InstallMethod( LocalizationFunctor,
              [ IsHomotopyCategory ],
  function( homotopy )
    local complexes, cat, D, r, name, F;
    
    complexes := UnderlyingCategory( homotopy );
    
    cat := UnderlyingCategory( complexes );
    
    D := DerivedCategory( cat );
    
    name := "Localization functor in derived category";
    
    F := CapFunctor( name, homotopy, D );
    
    AddObjectFunction( F,
      function( a )
        
        return a / D;
        
    end );
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        
        return alpha / D;
        
    end );
    
    return F;
    
end );

##
InstallMethod( UniversalFunctorFromDerivedCategory,
          [ IsCapFunctor ],
  function( F )
    local homotopy_cat, C, cat, D, r, name, U;
    
    homotopy_cat := AsCapCategory( Source( F ) );
    
    C := AsCapCategory( Range( F ) );
    
    if not IsHomotopyCategory( homotopy_cat ) then
      
      Error( "The input be a functor from homotopy category of some abelian category" );
      
    fi;
    
    cat := DefiningCategory( homotopy_cat );
    
    D := DerivedCategory( cat );
    
    name := "Universal functor from derived category into a localization category";
    
    U := CapFunctor( name, D, C );
    
    AddObjectFunction( U,
      function( a )
        
        return ApplyFunctor( F, UnderlyingCell( a ) );
        
    end );
    
    AddMorphismFunction( U,
      function( s, alpha, r )
        local i, j;
        
        i := ApplyFunctor( F, SourceMorphism( UnderlyingRoof( alpha ) ) );
        
        j := ApplyFunctor( F, RangeMorphism( UnderlyingRoof( alpha ) ) );
        
        return PreCompose( Inverse( i ), j );
        
    end );
    
    return U;
    
end );

##
InstallMethod( LDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local H_1, cat_1, D_1, H_2, cat_2, D_2, name, LF, r;
    
    H_1 := AsCapCategory( Source( F ) );
    
    H_2 := AsCapCategory( Range( F ) );
    
    if not ( IsHomotopyCategory( H_1 ) and IsHomotopyCategory( H_2 ) ) then
      
      TryNextMethod( );
      
    fi;
    
    cat_1 := DefiningCategory( H_1 );
    
    D_1 := DerivedCategory( cat_1 );
    
    cat_2 := DefiningCategory( H_2 );
    
    D_2 := DerivedCategory( cat_2 );
    
    if not IsAbelianCategoryWithComputableEnoughProjectives( cat_1 ) then
      
      Error( Name( cat_1 ), " should be abelian with enough projectives!\n" );
      
    fi;
    
    name := "Left derived functor";
    
    LF := CapFunctor( name, D_1, D_2 );
    
    AddObjectFunction( LF,
      function( a )
        local p;
        
        p := ProjectiveResolution( UnderlyingCell( UnderlyingCell( a ) ), true ) / H_1;
        
        return ApplyFunctor( F, p ) / D_2;
        
    end );
    
    AddMorphismFunction( LF,
      function( s, alpha, r )
        local roof, quasi_iso, morphism, F_quasi_iso, F_morphism;
        
        roof := UnderlyingRoof( alpha );
        
        quasi_iso := SourceMorphism( roof );
        
        quasi_iso := MorphismBetweenProjectiveResolutions( UnderlyingCell( quasi_iso ), true ) / H_1;
        
        morphism := RangeMorphism( roof );
        
        morphism := MorphismBetweenProjectiveResolutions( UnderlyingCell( morphism ), true ) / H_1;
        
        F_quasi_iso := ApplyFunctor( F, quasi_iso );
        
        F_morphism := ApplyFunctor( F, morphism );
        
        roof := Roof( F_quasi_iso, F_morphism );
        
        return DerivedCategoryMorphism( s, roof, r );
        
    end );
    
    return LF;
    
end );

##
InstallMethod( LDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local cat_1;
    
    cat_1 := AsCapCategory( Source( F ) );
    
    if not ( HasIsAbelianCategory( cat_1 )
                and IsAbelianCategory( cat_1 )
                  and IsAbelianCategoryWithComputableEnoughProjectives( cat_1 ) ) then
                  
      TryNextMethod( );
      
    fi;
    
    return LDerivedFunctor( ExtendFunctorToHomotopyCategories( F ) );
    
end );

InstallMethod( LeftDerivedFunctor, [ IsCapFunctor ], LDerivedFunctor );

##
InstallMethod( RDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local H_1, cat_1, D_1, H_2, cat_2, D_2, name, RF, r;
    
    H_1 := AsCapCategory( Source( F ) );
    
    H_2 := AsCapCategory( Range( F ) );
    
    if not ( IsHomotopyCategory( H_1 ) and IsHomotopyCategory( H_2 ) ) then
      
      TryNextMethod( );
      
    fi;
    
    cat_1 := DefiningCategory( H_1 );
    
    D_1 := DerivedCategory( cat_1 );
    
    cat_2 := DefiningCategory( H_2 );
    
    D_2 := DerivedCategory( cat_2 );
    
    if not IsAbelianCategoryWithComputableEnoughInjectives( cat_1 ) then
      
      Error( Name( cat_1 ), " should be abelian with enough injectives!\n" );
      
    fi;
    
    name := "Right derived functor";
       
    RF := CapFunctor( name, D_1, D_2 );
    
    AddObjectFunction( RF,
      function( a )
        local i;
        
        i := InjectiveResolution( UnderlyingCell( UnderlyingCell( a ) ), true ) / H_1;
        
        return ApplyFunctor( F, i ) / D_2;
        
    end );
    
    AddMorphismFunction( RF,
      function( s, alpha, r )
        local roof, quasi_iso, morphism, F_quasi_iso, F_morphism;
        
        roof := UnderlyingRoof( alpha );
        
        quasi_iso := SourceMorphism( roof );
        
        quasi_iso := MorphismBetweenInjectiveResolutions( UnderlyingCell( quasi_iso ), true ) / H_1;
        
        morphism := RangeMorphism( roof );
        
        morphism := MorphismBetweenInjectiveResolutions( UnderlyingCell( morphism ), true ) / H_1;
        
        F_quasi_iso := ApplyFunctor( F, quasi_iso );
        
        F_morphism := ApplyFunctor( F, morphism );
        
        roof := Roof( F_quasi_iso, F_morphism );
        
        return DerivedCategoryMorphism( s, roof, r );
        
    end );
    
    return RF;
    
end );

##
InstallMethod( RDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local cat_1;
    
    cat_1 := AsCapCategory( Source( F ) );
    
    if not ( HasIsAbelianCategory( cat_1 )
                and IsAbelianCategory( cat_1 )
                  and IsAbelianCategoryWithComputableEnoughInjectives( cat_1 ) ) then
                  
      TryNextMethod( );
      
    fi;
    
    return RDerivedFunctor( ExtendFunctorToHomotopyCategories( F ) );
    
end );

##
InstallMethod( RightDerivedFunctor, [ IsCapFunctor ], RDerivedFunctor );

########################################
#
# Convolution functor
#
########################################

##
InstallMethod( EquivalenceFunctorFromAdditiveClosure,
          [ IsCapFullSubcategory ],
  function( full )
    local I, add_closure_full;
    
    I := InclusionFunctor( full );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    add_closure_full := AdditiveClosureAsFullSubcategory( full );
    
    I := RestrictFunctorToFullSubcategoryOfRange( I, add_closure_full );
    
    I!.Name := "Isomorphism functor from formal additive closure into additive colsure as full subcategory";
    
    return I;
    
end );

##
InstallMethod( EquivalenceFunctorFromAdditiveClosure,
          [ IsExceptionalCollection ],
  collection -> EquivalenceFunctorFromAdditiveClosure( DefiningFullSubcategory( collection ) )
);

##
InstallMethod( EquivalenceFunctorFromHomotopyCategory,
          [ IsExceptionalCollection ],
  collection -> ExtendFunctorToHomotopyCategories( EquivalenceFunctorFromAdditiveClosure( collection ) )
);

##
InstallMethod( EmbeddingFunctorFromAdditiveClosure,
          [ IsCapFullSubcategory ],
  function( full )
    local I, add_closure_full;
    
    I := InclusionFunctor( full );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I!.Name := "Embedding functor from formal additive closure into the ambient category";
    
    return I;
    
end );

##
InstallMethod( EmbeddingFunctorFromAdditiveClosure,
          [ IsExceptionalCollection ],
  collection -> EmbeddingFunctorFromAdditiveClosure( DefiningFullSubcategory( collection ) )
);

##
InstallMethod( EmbeddingFunctorFromHomotopyCategory,
          [ IsExceptionalCollection ],
  collection -> ExtendFunctorToHomotopyCategories( EmbeddingFunctorFromAdditiveClosure( collection ) )
);

##
BindGlobal( "SET_COMMUTATIVITY_NAT_ISO_BETWEEN_REPLACEMENT_AND_SHIFT",
  function( collection, rep )
    local D, sigma_D, C, sigma_C, rep_o_sigma_C, sigma_D_o_rep, name, eta;
    
    D := HomotopyCategory( collection );
    
    sigma_D := ShiftFunctor( D );
    
    C := AmbientCategory( collection );
    
    sigma_C := ShiftFunctor( C );
    
    rep_o_sigma_C := PostCompose( rep, sigma_C );
    
    sigma_D_o_rep := PostCompose( sigma_D, rep );
    
    name := "Natural isomorphism G o Σ => Σ o G";
    
    eta := NaturalTransformation( name, rep_o_sigma_C, sigma_D_o_rep );
    
    AddNaturalTransformationFunction( eta,
      function( rep_o_sigma_a, a, sigma_D_o_rep_a )
        local z_func;
        
        z_func := AsZFunction( i -> ( -1 ) ^ ( i - 1 ) * IdentityMorphism( rep_o_sigma_a[ i ] ) );
        
        return HomotopyCategoryMorphism( rep_o_sigma_a, sigma_D_o_rep_a, z_func );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( rep, eta );
   
end );

##
InstallMethod( ReplacementFunctor,
          [ IsExceptionalCollection ],
  function( collection )
    local C, H, name, rep;
    
    C := AmbientCategory( collection );
    
    H := HomotopyCategory( collection );
    
    name := "Replacement functor";
    
    rep := CapFunctor( name, C, H );
    
    AddObjectFunction( rep,
      a -> ExceptionalReplacement( a, collection, true )
    );
    
    AddMorphismFunction( rep,
      { s, alpha, r } -> ExceptionalReplacement( alpha, collection, true )
    );
    
    SET_COMMUTATIVITY_NAT_ISO_BETWEEN_REPLACEMENT_AND_SHIFT( collection, rep );
    
    return rep;
    
end );

##
InstallMethod( ReplacementFunctorIntoHomotopyCategoryOfAdditiveClosureOfAlgebroid,
          [ IsExceptionalCollection ],
  function( collection )
    local G, eta_G, J, eta_J, GJ, sigma_S, sigma_T, GJ_o_sigma_S, sigma_T_o_GJ, eta;
    
    G := ReplacementFunctor( collection );
    
    eta_G := CommutativityNaturalTransformationWithShiftFunctor( G );
    
    J := IsomorphismOntoAlgebroid( collection );
    
    J := ExtendFunctorToAdditiveClosureOfSource( J );
    
    J := ExtendFunctorToHomotopyCategories( J );
    
    eta_J := CommutativityNaturalTransformationWithShiftFunctor( J );
    
    GJ := PreCompose( G, J );
    
    sigma_S := ShiftFunctor( AsCapCategory( Source( GJ ) ) );

    sigma_T := ShiftFunctor( AsCapCategory( Range( GJ ) ) );

    GJ_o_sigma_S := PostCompose( GJ, sigma_S );

    sigma_T_o_GJ := PostCompose( sigma_T, GJ );

    eta := NaturalTransformation( "Natural isomorphism G o Σ => Σ o G", GJ_o_sigma_S, sigma_T_o_GJ );
    
    AddNaturalTransformationFunction( eta,
      function( GJ_o_sigma_S_a, a, sigma_T_o_GJ_a )
      
        return PreCompose(
                  ApplyFunctor( J, ApplyNaturalTransformation( eta_G, a ) ),
                  ApplyNaturalTransformation( eta_J, ApplyFunctor( G, a ) )
                );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( GJ, eta );
    
    GJ!.Name := "Replacement functor";
    
    return GJ;
    
end );

##
InstallMethod( ReplacementFunctorIntoHomotopyCategoryOfQuiverRows,
          [ IsExceptionalCollection ],
  function( collection )
    local G, eta_G, C, J, eta_J, GJ, sigma_S, sigma_T, GJ_o_sigma_S, sigma_T_o_GJ, eta;
    
    G := ReplacementFunctorIntoHomotopyCategoryOfAdditiveClosureOfAlgebroid( collection );
    
    eta_G := CommutativityNaturalTransformationWithShiftFunctor( G );
    
    C := Algebroid( collection );
    
    C := AdditiveClosure( C );
    
    J := IsomorphismOntoQuiverRows( C );
    
    J := ExtendFunctorToHomotopyCategories( J );
        
    eta_J := CommutativityNaturalTransformationWithShiftFunctor( J );
    
    GJ := PreCompose( G, J );
    
    sigma_S := ShiftFunctor( AsCapCategory( Source( GJ ) ) );

    sigma_T := ShiftFunctor( AsCapCategory( Range( GJ ) ) );

    GJ_o_sigma_S := PostCompose( GJ, sigma_S );

    sigma_T_o_GJ := PostCompose( sigma_T, GJ );

    eta := NaturalTransformation( "Natural isomorphism G o Σ => Σ o G", GJ_o_sigma_S, sigma_T_o_GJ );
    
    AddNaturalTransformationFunction( eta,
      function( GJ_o_sigma_S_a, a, sigma_T_o_GJ_a )
      
        return PreCompose(
                  ApplyFunctor( J, ApplyNaturalTransformation( eta_G, a ) ),
                  ApplyNaturalTransformation( eta_J, ApplyFunctor( G, a ) )
                );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( GJ, eta );
    
    GJ!.Name := "Replacement functor";
    
    return GJ;
   
end );

BindGlobal( "SET_COMMUTATIVITY_NAT_ISO_BETWEEN_CONVOLUTION_AND_SHIFT",
  function( collection, conv )
    local D, sigma_D, C, sigma_C, conv_o_sigma_D, sigma_C_o_conv, name, eta;
    
    D := HomotopyCategory( collection );
    
    sigma_D := ShiftFunctor( D );
    
    C := AmbientCategory( collection );
    
    sigma_C := ShiftFunctor( C );
    
    conv_o_sigma_D := PostCompose( conv, sigma_D );
    
    sigma_C_o_conv := PostCompose( sigma_C, conv );
    
    name := "Natural isomorphism F o Σ => Σ o F";
    
    eta := NaturalTransformation( name, conv_o_sigma_D, sigma_C_o_conv );
    
    AddNaturalTransformationFunction( eta,
      function( conv_o_sigma_D_a, a, sigma_C_o_conv_a )
        local diffs, b, z_func, alpha;
        
        diffs := Differentials( a );
        
        diffs := ApplyMap( diffs, AdditiveInverse );
        
        b := HomotopyCategoryObject( D, diffs );
        
        SetLowerBound( b, ActiveLowerBound( a ) );
        
        SetUpperBound( b, ActiveUpperBound( a ) );
        
        z_func := AsZFunction( i -> ( -1 ) ^ i * IdentityMorphism( a[ i ] ) );
        
        alpha := HomotopyCategoryMorphism( a, b, z_func );
        
        alpha := conv_o_sigma_D( alpha );
                
        return alpha;
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( conv, eta );
   
end );

##
InstallMethod( ConvolutionFunctor,
          [ IsExceptionalCollection ],
  function( collection )
    local conv;
    
    conv := CONVOLUTION_FUNCTOR( HomotopyCategory( collection ) );
    
    SET_COMMUTATIVITY_NAT_ISO_BETWEEN_CONVOLUTION_AND_SHIFT( collection, conv );
    
    return conv;
    
end );

##
InstallMethod( ConvolutionFunctorFromHomotopyCategoryOfAdditiveClosureOfAlgebroid,
    [ IsExceptionalCollection ],
  function( collection )
    local I, eta_I, F, eta_F, IF, sigma_S, sigma_T, IF_o_sigma_S, sigma_T_o_IF, eta;
    
    I := IsomorphismFromAlgebroid( collection );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I := ExtendFunctorToHomotopyCategories( I );
    
    eta_I := CommutativityNaturalTransformationWithShiftFunctor( I );
    
    F := ConvolutionFunctor( collection );
    
    eta_F := CommutativityNaturalTransformationWithShiftFunctor( F );
    
    IF := PreCompose( I, F );
    
    sigma_S := ShiftFunctor( AsCapCategory( Source( IF ) ) );

    sigma_T := ShiftFunctor( AsCapCategory( Range( IF ) ) );

    IF_o_sigma_S := PostCompose( IF, sigma_S );

    sigma_T_o_IF := PostCompose( sigma_T, IF );

    eta := NaturalTransformation( "Natural isomorphism F o Σ => Σ o F", IF_o_sigma_S, sigma_T_o_IF );
    
    AddNaturalTransformationFunction( eta,
      function( IF_o_sigma_S_a, a, sigma_T_o_IF_a )
      
        return PreCompose(
                  ApplyFunctor( F, ApplyNaturalTransformation( eta_I, a ) ),
                  ApplyNaturalTransformation( eta_F, ApplyFunctor( I, a ) )
                );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( IF, eta );
    
    IF!.Name := "Convolution functor";
    
    return IF;
    
end );

##
##
InstallMethod( ConvolutionFunctorFromHomotopyCategoryOfQuiverRows,
    [ IsExceptionalCollection ],
  function( collection )
    local C, I, eta_I, F, eta_F, IF, sigma_S, sigma_T, IF_o_sigma_S, sigma_T_o_IF, eta;
    
    C := Algebroid( collection );
    
    C := AdditiveClosure( C );
    
    I := IsomorphismFromQuiverRows( C ); 
    
    I := ExtendFunctorToHomotopyCategories( I );
     
    eta_I := CommutativityNaturalTransformationWithShiftFunctor( I );
    
    F := ConvolutionFunctorFromHomotopyCategoryOfAdditiveClosureOfAlgebroid( collection );
    
    eta_F := CommutativityNaturalTransformationWithShiftFunctor( F );
    
    IF := PreCompose( I, F );
    
    sigma_S := ShiftFunctor( AsCapCategory( Source( IF ) ) );

    sigma_T := ShiftFunctor( AsCapCategory( Range( IF ) ) );

    IF_o_sigma_S := PostCompose( IF, sigma_S );

    sigma_T_o_IF := PostCompose( sigma_T, IF );

    eta := NaturalTransformation( "Natural isomorphism F o Σ => Σ o F", IF_o_sigma_S, sigma_T_o_IF );
    
    AddNaturalTransformationFunction( eta,
      function( IF_o_sigma_S_a, a, sigma_T_o_IF_a )
      
        return PreCompose(
                  ApplyFunctor( F, ApplyNaturalTransformation( eta_I, a ) ),
                  ApplyNaturalTransformation( eta_F, ApplyFunctor( I, a ) )
                );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( IF, eta );
    
    IF!.Name := "Convolution functor";
    
    return IF;
    
end );

##
InstallMethod( CONVOLUTION_FUNCTOR,
          [ IsHomotopyCategory ],
  function( Ho_Ho_0_C )
    local Ho_0_C, Ho_C, Inc, name, conv;
    
    if not IsHomotopyCategory( Ho_Ho_0_C ) then
      
      Error( "The input should be a homotopy category!\n" );
      
    fi;
    
    Ho_0_C := DefiningCategory( Ho_Ho_0_C );
    
    if not IsCapFullSubcategory( Ho_0_C ) then
      
      TryNextMethod( );
      
    fi;
    
    Ho_C := AmbientCategory( Ho_0_C );
    
    if not IsHomotopyCategory( Ho_C ) then
      
      Error( "The ambient category of the exceptional collection should be a homotopy category!\n" );
      
    fi;
    
    Inc := ExtendFunctorToHomotopyCategories( InclusionFunctor( Ho_0_C ) );
    
    name := "Convolution functor";
    
    conv := CapFunctor( name, Ho_Ho_0_C, Ho_C );
    
    AddObjectFunction( conv,
      a -> Convolution( ApplyFunctor( Inc, a ) )
    );
    
    AddMorphismFunction( conv,
      { s, alpha, r } -> Convolution( ApplyFunctor( Inc, alpha ) )
    );
   
    return conv;
    
end );

##
InstallMethod( CONVOLUTION_FUNCTOR,
          [ IsHomotopyCategory ],
  function( Ho_Ho_0_C )
    local Ho_0_C, D, I, H, Conv;
    
    if not IsHomotopyCategory( Ho_Ho_0_C ) then
      
      Error( "The input should be a homotopy category!\n" );
      
    fi;
    
    Ho_0_C := DefiningCategory( Ho_Ho_0_C );
    
    if not IsAdditiveClosureCategory( Ho_0_C ) then
      
      TryNextMethod( );
      
    fi;
    
    D := UnderlyingCategory( Ho_0_C );
    
    I := EquivalenceFunctorFromAdditiveClosure( D );
    
    I := ExtendFunctorToHomotopyCategories( I );
    
    H := AsCapCategory( Range( I ) );
    
    Conv := CONVOLUTION_FUNCTOR( H );
    
    Conv := PreCompose( I, Conv );
    
    Conv!.Name := "Convolution functor";
    
    return Conv;
    
end );


####################################
#
# Inverse of isomorphism functors
# Between k-linear categories with
# homomorphism structure
#
####################################

##
InstallMethod( ImageOfFullyFaithfullFunctor,
          [ IsCapFunctor ],
  function( I )
    local C, R, images_obj_C, r, name;
    
    C := AsCapCategory( Source( I ) );
    
    R := AsCapCategory( Range( I ) );
    
    if not IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C ) then
      
      TryNextMethod( );
      
    fi;
    
    images_obj_C := List( SetOfKnownObjects( C ), I );
    
    r := RandomTextColor( Name( R ) );
    
    name := Concatenation( r[ 1 ], "Full subcategory( ", r[ 2 ], Name( R ), r[ 1 ],
        " ) generated by the values of a fully faithful functor", r[ 2 ] );
        
    return FullSubcategoryGeneratedByListOfObjects( images_obj_C : name_of_full_subcategory := name );
    
end );

##
InstallMethod( IsomorphismOntoImageOfFullyFaithfulFunctor,
          [ IsCapFunctor ],
  function( I )
    local C, D, r, name;
    
    C := AsCapCategory( Source( I ) );
    
    if not IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C ) then
      
      TryNextMethod( );
      
    fi;
    
    D := ImageOfFullyFaithfullFunctor( I );
    
    r := RandomTextColor( Name( I ) );
    
    name := Concatenation( r[ 1 ], "Isomorphism functor into the image ( ", r[ 2 ],
              Name( I ), r[ 1 ], " ) ", r[ 2 ]
              );
              
    I := RestrictFunctorToFullSubcategoryOfRange( I, D );
    
    I!.Name := name;
    
    return I;
    
end );

##
InstallMethod( IsomorphismFromImageOfFullyFaithfulFunctor,
          [ IsCapFunctor ],
  function( I )
    local C, D, object_func, images_of_morphisms_D, morphism_func, r, name;
    
    C := AsCapCategory( Source( I ) );
     
    if not IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C ) then
      
      TryNextMethod( );
      
    fi;
    
    D := ImageOfFullyFaithfullFunctor( I );
    
    object_func := o -> C[ Position( SetOfKnownObjects( D ), o ) ];
    
    images_of_morphisms_D := [ [ ], [ ] ];
    
    morphism_func :=
      function( alpha )
        local a, b, pre_a, pre_b, p, B_pre_a_pre_b, B_a_b, morphism_1, I_B_pre_a_pre_b, morphism_2, lift, coeffs;
        
        a := Source( alpha );
        
        b := Range( alpha );
        
        B_a_b := BasisOfExternalHom( a, b );
        
        pre_a := object_func( a );
        
        pre_b := object_func( b );
        
        p := Position( images_of_morphisms_D[ 1 ], [ a, b ] );
        
        if p = fail then
          
          B_pre_a_pre_b := BasisOfExternalHom( pre_a, pre_b );
          
          morphism_1 := InterpretListOfMorphismsAsOneMorphismInRangeCategoryOfHomomorphismStructure( a, b, B_a_b );
          
          I_B_pre_a_pre_b := List( B_pre_a_pre_b, m -> I( m ) / D );
          
          morphism_2 := InterpretListOfMorphismsAsOneMorphismInRangeCategoryOfHomomorphismStructure( a, b, I_B_pre_a_pre_b );
          
          lift := Lift( morphism_1, morphism_2 );
          
          coeffs := EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( lift ) );
          
          Add( images_of_morphisms_D[ 1 ], [ a, b ] );
          
          Add( images_of_morphisms_D[ 2 ], List( coeffs, c -> c * B_pre_a_pre_b ) );
          
          p := Size( images_of_morphisms_D[ 1 ] );
          
        fi;
        
        return CoefficientsOfMorphismWithGivenBasisOfExternalHom( alpha, B_a_b ) * images_of_morphisms_D[ 2 ][ p ];
        
    end;
    
    r := RandomTextColor( Name( I ) );
    
    name := Concatenation( r[ 1 ], "Isomorphism functor from the image ( ", r[ 2 ],
              Name( I ), r[ 1 ], " ) ", r[ 2 ]
              );
              
    return FunctorFromLinearCategoryByTwoFunctions( name, D, C, object_func, morphism_func );
    
end );

###################################
#
# Embedding in derived category
#
###################################

##
InstallMethod( EmbeddingFunctorFromAmbientCategoryIntoDerivedCategory,
          [ IsExceptionalCollection ],
  collection -> EmbeddingFunctorIntoDerivedCategory( AmbientCategory( collection ) )
);

##
InstallMethod( EmbeddingFunctorIntoDerivedCategory,
          [ IsCapCategory ],
  function( C )
    local Ho_C, I, J, F, D, A, U, k, algebroid, add_algebroid;
    
    if HasIsAbelianCategory( C ) and IsAbelianCategory( C ) then
      
      Ho_C := HomotopyCategory( C );
      
      I := EmbeddingFunctorInHomotopyCategory( C );
      J := LocalizationFunctor( Ho_C );
      
      F := PreCompose( I, J );
      
      F!.Name := "Embedding functor of an abelian category in its derived category";
      
      return F;
      
    elif IsHomotopyCategory( C ) then
      
      D := DefiningCategory( C );
      
      if IsCapFullSubcategory( D ) then
        
        if HasIsAdditiveCategory( D ) and IsAdditiveCategory( D ) then
          
          A := AmbientCategory( D );
          
          if HasIsAbelianCategory( A ) and IsAbelianCategory( A ) then
            
            I := InclusionFunctor( D );
            
            I := ExtendFunctorToHomotopyCategories( I );
            
            J := LocalizationFunctor( AsCapCategory( Range( I ) ) );
            
            F := PreCompose( I, J );
            
            F!.Name := "Equivalence functor from homotopy category into derived category";
            
            return F;
            
          else
            
            return fail;
            
          fi;
          
        else
          
          return fail;
          
        fi;
        
      elif IsAdditiveClosureCategory( D ) then
        
        U := UnderlyingCategory( D );
        
        if IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( U ) then
          
          A := AmbientCategory( U );
          
          if HasIsAbelianCategory( A ) and IsAbelianCategory( A ) then
            
            I := ExtendFunctorToAdditiveClosureOfSource( InclusionFunctor( U ) );
            
            I := ExtendFunctorToHomotopyCategories( I );
            
            J := LocalizationFunctor( AsCapCategory( Range( I ) ) );
            
            F := PreCompose( I, J );
            
            F!.Name := "Equivalence functor from homotopy category into derived category";
            
            return F;
            
          else
            
            return fail;
            
          fi;
        
        elif IsAlgebroid( U ) then
          
          I := IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( U );
          
          I := PreCompose( I, InclusionFunctor( AsCapCategory( Range( I ) ) ) );
          
          I := ExtendFunctorToAdditiveClosureOfSource( I );
          
          I := ExtendFunctorToHomotopyCategories( I );
          
          J := LocalizationFunctor( AsCapCategory( Range( I ) ) );
          
          F := PreCompose( I, J );
          
          F!.Name := "Equivalence functor from homotopy category into derived category";
          
          return F;
          
        else
          
          return fail;
          
        fi;
      
      elif IsQuiverRowsCategory( D ) then
        
        A := UnderlyingQuiverAlgebra( D );
        
        k := CommutativeRingOfLinearCategory( D );
        
        if ( HasIsIntegersForHomalg( k ) and IsIntegersForHomalg( k ) ) or IsIntegers( k ) then
          
          algebroid := Algebroid( A, true );
          
        else
          
          algebroid := Algebroid( A );
          
        fi;
        
        add_algebroid := AdditiveClosure( algebroid );
        
        I := IsomorphismFromQuiverRowsIntoAdditiveClosureOfAlgebroid( D, add_algebroid );
        
        I := ExtendFunctorToHomotopyCategories( I );
        
        F := EmbeddingFunctorIntoDerivedCategory( HomotopyCategory( add_algebroid ) );
        
        F := PreCompose( I, F );
        
        F!.Name := "Equivalence functor from homotopy category into derived category";
        
        return F;
        
      else
        
        return fail;
        
      fi;
      
    elif IsDerivedCategory( C ) then
      
      return IdentityFunctor( C );
      
    else
      
      return fail;
      
    fi;
    
end );
