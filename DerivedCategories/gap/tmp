    #       Z
    #      / \
    #    4     5
    #    X     Y
    #   / \   / \
    # A     B     C
    # 1     2     3

objects := [ [ "A", [-2,2] ], [ "B", [-2,2] ], [ "C", [-2,2] ], [ "X", [-2,2] ], [ "Y", [-2,2] ] ];
morphisms := [ [ "q_1", [ 4, 1 ], 0, [-2,2], "q_{1}" ],
               [ "r_1", [ 4, 2 ], 0, [-2,2], "r_{1}" ],
               [ "q_2", [ 5, 2 ], 0, [-2,2], "q_{2}"],
               [ "r_2", [ 5, 3 ], 0, [-2,2], "r_{2}"] ];
relations := [ [ "Differential( q_1 )", 4 ],
               [ "Differential( r_1 )", 4 ],
               [ "Differential( q_2 )", 5 ],
               [ "Differential( r_2 )", 5 ] ];
cat := AdditiveClosure( oid );;
homotopy_cat := HomotopyCategoryByCochains( cat );;
complex_cat := UnderlyingCategory( homotopy_cat );;
for object_info in objects do
   MakeReadWriteGlobal( object_info[1] );
   DeclareSynonym( object_info[1],
     ObjectConstructor(
       homotopy_cat,
       CreateComplex(
         complex_cat,
         List( [ object_info[2][1] .. object_info[2][2] - 1 ],
           i -> oid.( Concatenation( "d", object_info[1], "_", ReplacedString( String(i), "-", "m" ) ) ) / cat ),
         object_info[2][1] ) ) );
od;
for morphism_info in morphisms{[1..4]} do
   MakeReadWriteGlobal( morphism_info[1] );
   DeclareSynonym( morphism_info[1],
     MorphismConstructor(
       homotopy_cat,
       EvalString( objects[morphism_info[2][1]][1] ),
       CreateComplexMorphism(
         complex_cat,
         UnderlyingCell( EvalString( objects[morphism_info[2][1]][1] ) ),
         UnderlyingCell( EvalString( objects[morphism_info[2][2]][1] ) ),
         List( [ morphism_info[4][1] .. morphism_info[4][2] ], i -> oid.( Concatenation( morphism_info[1], "_", ReplacedString( String(i), "-", "m" ) ) ) / cat ),
         morphism_info[4][1] ),
       EvalString( objects[morphism_info[2][2]][1] ) ) );
od;
